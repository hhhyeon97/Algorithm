

// https://www.acmicpc.net/problem/1676
// 팩토리얼 0의 개수

// 17724KB	168ms

/*
팩토리얼(Factorial) 값에서 뒤쪽에 있는 0의 개수를 구하는 문제
뒤에 있는 0은 10이 곱해질 때마다 하나씩 생기는데, 10은 2와 5의 곱으로 만들 수 있다. 
팩토리얼을 계산할 때 2의 배수는 항상 5의 배수보다 많기 때문에, 
5의 배수의 개수를 세는 것으로 문제를 해결할 수 있다.

접근 방법:
N!에서 뒤쪽의 0은 2와 5가 곱해져서 만들어진다. 
2는 항상 충분히 많기 때문에, 5의 개수만 세면 된다.
N 이하의 5의 배수들을 찾고, 그 배수들이 몇 개의 5를 포함하는지 확인한다.
5의 배수 하나당 0이 하나 생긴다.
25의 배수는 5가 두 번 곱해지기 때문에 0이 추가로 더 생긴다.
125의 배수는 5가 세 번 곱해지기 때문에 0이 추가로 더 생긴다.

해결 방법:
N 이하의 5의 배수들을 차례로 확인하고 그 개수를 세면 된다.

========================================================================================
*/

/*
 * 10은 2와 5의 곱(10 = 2 * 5)으로 이루어진다. 
 * 따라서 팩토리얼 계산에서 0이 하나 생기려면 2와 5가 곱해져야 한다.
 * 그러나 팩토리얼을 계산할 때 2의 배수는 매우 자주 등장한다. 
 * 예를 들어, 2, 4, 6, 8, 10, 12, 14, ... 등 많은 수가 2의 배수이다.
 * 반면, 5의 배수는 상대적으로 적다. 5, 10, 15, 20, ... 이런 식으로 등장한다.
 * 팩토리얼에서 0을 만들기 위해서는 2와 5가 쌍을 이루어야 10이 만들어지는데, 
 * 2는 항상 5보다 많이 존재하기 때문에 5의 개수가 0의 개수를 결정하게 된다.
 * 따라서 5의 배수만 세면 충분하다는 의미로 "2는 충분히 많다"라고 표현한 것이다.
 */


import java.util.Scanner;

public class 1676번 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int count = 0;
        
        // for문을 통해 5의 배수, 25의 배수, 125의 배수 등 N 이하의 값에서 몇 개의 5가 있는지 계산한다.
        /*
            N을 5로 나누면 5의 배수의 개수가 나온다.
            N을 25로 나누면 25의 배수의 개수가 나온다.
            이런 식으로 반복해서 N 이하에서 모든 5의 배수를 센다.
        */
        for (int i = 5; i <= N; i *= 5) {
            count += N / i;
        }

        /*
        ex ) 
        N = 10인 경우, 10! = 3628800이므로 뒤에 0이 2개 있다.
        5의 배수는 5, 10이므로 0이 2개 생긴다.
        N = 3인 경우, 3! = 6이므로 뒤에 0이 없다.
        팩토리얼 값을 직접 계산하지 않고 푸는 방식으로 접근한 것
        */

        //5의 개수 출력
        System.out.println(count);
    }
}